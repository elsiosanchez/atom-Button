{
  "version": 3,
  "sources": ["../../../packages/components/space/src/item.ts", "../../../packages/components/space/src/use-space.ts", "../../../packages/components/space/src/space.ts", "../../../packages/components/space/index.ts"],
  "sourcesContent": ["import { computed, defineComponent, h, renderSlot } from 'vue'\nimport { buildProps } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport type { ExtractPropTypes } from 'vue'\n\nconst spaceItemProps = buildProps({\n  prefixCls: {\n    type: String,\n  },\n} as const)\nexport type SpaceItemProps = ExtractPropTypes<typeof spaceItemProps>\n\nconst SpaceItem = defineComponent({\n  name: 'ElSpaceItem',\n\n  props: spaceItemProps,\n\n  setup(props, { slots }) {\n    const ns = useNamespace('space')\n\n    const classes = computed(() => `${props.prefixCls || ns.b()}__item`)\n\n    return () =>\n      h('div', { class: classes.value }, renderSlot(slots, 'default'))\n  },\n})\nexport type SpaceItemInstance = InstanceType<typeof SpaceItem>\n\nexport default SpaceItem\n", "import { computed, ref, watchEffect } from 'vue'\nimport { isArray, isNumber } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport type { SpaceProps } from './space'\nimport type { CSSProperties, StyleValue } from 'vue'\n\nconst SIZE_MAP = {\n  small: 8,\n  default: 12,\n  large: 16,\n} as const\n\nexport function useSpace(props: SpaceProps) {\n  const ns = useNamespace('space')\n\n  const classes = computed(() => [ns.b(), ns.m(props.direction), props.class])\n\n  const horizontalSize = ref(0)\n  const verticalSize = ref(0)\n\n  const containerStyle = computed<StyleValue>(() => {\n    const wrapKls: CSSProperties =\n      props.wrap || props.fill\n        ? { flexWrap: 'wrap', marginBottom: `-${verticalSize.value}px` }\n        : {}\n    const alignment: CSSProperties = {\n      alignItems: props.alignment,\n    }\n    return [wrapKls, alignment, props.style]\n  })\n\n  const itemStyle = computed<StyleValue>(() => {\n    const itemBaseStyle: CSSProperties = {\n      paddingBottom: `${verticalSize.value}px`,\n      marginRight: `${horizontalSize.value}px`,\n    }\n\n    const fillStyle: CSSProperties = props.fill\n      ? { flexGrow: 1, minWidth: `${props.fillRatio}%` }\n      : {}\n\n    return [itemBaseStyle, fillStyle]\n  })\n\n  watchEffect(() => {\n    const { size = 'small', wrap, direction: dir, fill } = props\n\n    // when the specified size have been given\n    if (isArray(size)) {\n      const [h = 0, v = 0] = size\n      horizontalSize.value = h\n      verticalSize.value = v\n    } else {\n      let val: number\n      if (isNumber(size)) {\n        val = size\n      } else {\n        val = SIZE_MAP[size || 'small'] || SIZE_MAP.small\n      }\n\n      if ((wrap || fill) && dir === 'horizontal') {\n        horizontalSize.value = verticalSize.value = val\n      } else {\n        if (dir === 'horizontal') {\n          horizontalSize.value = val\n          verticalSize.value = 0\n        } else {\n          verticalSize.value = val\n          horizontalSize.value = 0\n        }\n      }\n    }\n  })\n\n  return {\n    classes,\n    containerStyle,\n    itemStyle,\n  }\n}\n", "import {\n  createTextVNode,\n  createVNode,\n  defineComponent,\n  isVNode,\n  renderSlot,\n} from 'vue'\nimport { isString } from '@vue/shared'\nimport {\n  PatchFlags,\n  buildProps,\n  definePropType,\n  isArray,\n  isFragment,\n  isNumber,\n  isValidElementNode,\n} from '@element-plus/utils'\nimport { componentSizes } from '@element-plus/constants'\nimport Item from './item'\nimport { useSpace } from './use-space'\n\nimport type {\n  ExtractPropTypes,\n  StyleValue,\n  VNode,\n  VNodeArrayChildren,\n  VNodeChild,\n} from 'vue'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { AlignItemsProperty } from 'csstype'\n\nexport const spaceProps = buildProps({\n  /**\n   * @description Placement direction\n   */\n  direction: {\n    type: String,\n    values: ['horizontal', 'vertical'],\n    default: 'horizontal',\n  },\n  /**\n   * @description Classname\n   */\n  class: {\n    type: definePropType<Arrayable<Record<string, boolean> | string>>([\n      String,\n      Object,\n      Array,\n    ]),\n    default: '',\n  },\n  /**\n   * @description Extra style rules\n   */\n  style: {\n    type: definePropType<StyleValue>([String, Array, Object]),\n    default: '',\n  },\n  /**\n   * @description Controls the alignment of items\n   */\n  alignment: {\n    type: definePropType<AlignItemsProperty>(String),\n    default: 'center',\n  },\n  /**\n   * @description Prefix for space-items\n   */\n  prefixCls: {\n    type: String,\n  },\n  /**\n   * @description Spacer\n   */\n  spacer: {\n    type: definePropType<VNodeChild>([Object, String, Number, Array]),\n    default: null,\n    validator: (val: unknown) => isVNode(val) || isNumber(val) || isString(val),\n  },\n  /**\n   * @description Auto wrapping\n   */\n  wrap: Boolean,\n  /**\n   * @description Whether to fill the container\n   */\n  fill: Boolean,\n  /**\n   * @description Ratio of fill\n   */\n  fillRatio: {\n    type: Number,\n    default: 100,\n  },\n  /**\n   * @description Spacing size\n   */\n  size: {\n    type: [String, Array, Number],\n    values: componentSizes,\n    validator: (val: unknown): val is [number, number] | number => {\n      return (\n        isNumber(val) ||\n        (isArray(val) && val.length === 2 && val.every(isNumber))\n      )\n    },\n  },\n} as const)\nexport type SpaceProps = ExtractPropTypes<typeof spaceProps>\n\nconst Space = defineComponent({\n  name: 'ElSpace',\n\n  props: spaceProps,\n\n  setup(props, { slots }) {\n    const { classes, containerStyle, itemStyle } = useSpace(props)\n\n    // retrieve the children out via a simple for loop\n    // the edge case here is that when users uses directives like <v-for>, <v-if>\n    // we need to go deeper until the child is not the Fragment type\n    function extractChildren(\n      children: VNodeArrayChildren,\n      parentKey = '',\n      extractedChildren: VNode[] = []\n    ) {\n      const { prefixCls } = props\n      children.forEach((child, loopKey) => {\n        if (isFragment(child)) {\n          if (isArray(child.children)) {\n            child.children.forEach((nested, key) => {\n              if (isFragment(nested) && isArray(nested.children)) {\n                extractChildren(\n                  nested.children,\n                  `${parentKey + key}-`,\n                  extractedChildren\n                )\n              } else {\n                extractedChildren.push(\n                  createVNode(\n                    Item,\n                    {\n                      style: itemStyle.value,\n                      prefixCls,\n                      key: `nested-${parentKey + key}`,\n                    },\n                    {\n                      default: () => [nested],\n                    },\n                    PatchFlags.PROPS | PatchFlags.STYLE,\n                    ['style', 'prefixCls']\n                  )\n                )\n              }\n            })\n          }\n          // if the current child is valid vnode, then append this current vnode\n          // to item as child node.\n        } else if (isValidElementNode(child)) {\n          extractedChildren.push(\n            createVNode(\n              Item,\n              {\n                style: itemStyle.value,\n                prefixCls,\n                key: `LoopKey${parentKey + loopKey}`,\n              },\n              {\n                default: () => [child],\n              },\n              PatchFlags.PROPS | PatchFlags.STYLE,\n              ['style', 'prefixCls']\n            )\n          )\n        }\n      })\n\n      return extractedChildren\n    }\n\n    return () => {\n      const { spacer, direction } = props\n\n      const children = renderSlot(slots, 'default', { key: 0 }, () => [])\n\n      if ((children.children ?? []).length === 0) return null\n      // loop the children, if current children is rendered via `renderList` or `<v-for>`\n      if (isArray(children.children)) {\n        let extractedChildren = extractChildren(children.children)\n\n        if (spacer) {\n          // track the current rendering index, when encounters the last element\n          // then no need to add a spacer after it.\n          const len = extractedChildren.length - 1\n          extractedChildren = extractedChildren.reduce<VNode[]>(\n            (acc, child, idx) => {\n              const children = [...acc, child]\n              if (idx !== len) {\n                children.push(\n                  createVNode(\n                    'span',\n                    // adding width 100% for vertical alignment,\n                    // when the spacer inherit the width from the\n                    // parent, this span's width was not set, so space\n                    // might disappear\n                    {\n                      style: [\n                        itemStyle.value,\n                        direction === 'vertical' ? 'width: 100%' : null,\n                      ],\n                      key: idx,\n                    },\n                    [\n                      // if spacer is already a valid vnode, then append it to the current\n                      // span element.\n                      // otherwise, treat it as string.\n                      isVNode(spacer)\n                        ? spacer\n                        : createTextVNode(spacer as string, PatchFlags.TEXT),\n                    ],\n                    PatchFlags.STYLE\n                  )\n                )\n              }\n              return children\n            },\n            []\n          )\n        }\n\n        // spacer container.\n        return createVNode(\n          'div',\n          {\n            class: classes.value,\n            style: containerStyle.value,\n          },\n          extractedChildren,\n          PatchFlags.STYLE | PatchFlags.CLASS\n        )\n      }\n\n      return children.children\n    }\n  },\n})\n\nexport type SpaceInstance = InstanceType<typeof Space>\n\nexport default Space\n", "import { withInstall } from '@element-plus/utils'\n\nimport Space from './src/space'\n\nexport const ElSpace = withInstall(Space)\nexport default ElSpace\n\nexport * from './src/space'\nexport * from './src/item'\nexport * from './src/use-space'\n"],
  "mappings": "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",
  "names": ["h", "isNumber", "Item"]
}
